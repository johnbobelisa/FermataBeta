import cv2
import numpy as np
from ultralytics import YOLO
import os
from pathlib import Path
import json

class CustomHoldDetector:
    def __init__(self):
        """Initialize with your trained custom model"""
        # Path to your trained model
        self.model_path = "C:/Users/Kueh Tze Shuen/Documents/GitHub/FermataBeta/runs/detect/climbing_holds_custom/weights/best.pt"
        
        # Load the model
        try:
            self.model = YOLO(self.model_path)
            print(f"‚úÖ Custom model loaded successfully!")
            print(f"Model classes: {self.model.names}")
        except Exception as e:
            print(f"‚ùå Error loading model: {e}")
            raise
    
    def detect_holds(self, image_path, confidence_threshold=0.5):
        """Detect holds in an image"""
        if not os.path.exists(image_path):
            print(f"‚ùå Image not found: {image_path}")
            return None, []
        
        # Run inference
        results = self.model(image_path, conf=confidence_threshold)
        
        holds = []
        for result in results:
            boxes = result.boxes
            if boxes is not None:
                for box in boxes:
                    # Get bounding box coordinates
                    x1, y1, x2, y2 = box.xyxy[0].cpu().numpy()
                    confidence = box.conf[0].cpu().numpy()
                    id = int(box.cls[0].cpu().numpy())
                    
                    # Calculate center and size
                    xNorm = int((x1 + x2) / 2)
                    yNorm = int((y1 + y2) / 2)
                    width = int(x2 - x1)
                    height = int(y2 - y1)
                    
                    # Get class name
                    type = self.model.names[id]
                    
                    holds.append({
                        'id': id,
                        'type': type,
                        'center_px': (xNorm, yNorm),
                        'confidence': float(confidence),
                        'bbox': (int(x1), int(y1), width, height),
                        
                        
                    })
        
        return results[0].orig_img, holds
    
    def draw_detections(self, image, holds):
        """Draw detected holds on the image"""
        # Color mapping for different classes
        colors = {
            0: (0, 255, 0),    # Green for holds
            1: (255, 0, 0),    # Blue for volumes
        }
        
        for i, hold in enumerate(holds):
            id = hold['id']
            type = hold['type']
            
            xNorm, yNorm = hold['center_px']
            confidence = hold['confidence']
            
            x, y, w, h = hold['bbox']
            
            # Choose color based on class
            color = colors.get(id, (255, 255, 255))
            
            # Draw bounding box
            cv2.rectangle(image, (x, y), (x + w, y + h), color, 2)
            
            # Draw center point
            cv2.circle(image, (xNorm, yNorm), 5, color, -1)
            
            # Draw label
            label = f"{type} {confidence:.2f}"
            label_size = cv2.getTextSize(label, cv2.FONT_HERSHEY_SIMPLEX, 0.5, 2)[0]
            
            # Background for text
            cv2.rectangle(image, (x, y - label_size[1] - 10), 
                         (x + label_size[0], y), color, -1)
            
            # Text
            cv2.putText(image, label, (x, y - 5),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)
            
            # Number the holds
            cv2.putText(image, str(i + 1), (xNorm - 10, yNorm + 5),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)
        
        return image
    
    def process_image(self, image_path, save_result=True):
        """Complete processing pipeline"""
        print(f"üîç Processing: {image_path}")
        
        # Detect holds
        original_image, holds = self.detect_holds(image_path)
        
        if original_image is None:
            return None
        
        # Draw results
        result_image = self.draw_detections(original_image.copy(), holds)
        
        # Print results
        print(f"‚úÖ Found {len(holds)} objects:")
        
        class_counts = {}
        for hold in holds:
            type = hold['type']
            class_counts[type] = class_counts.get(type, 0) + 1
            print(f"   {hold['type']}: confidence {hold['confidence']:.3f}")
        
        print(f"\nüìä Summary:")
        for type, count in class_counts.items():
            print(f"   {type}: {count} detected")
        
        # Save result
        if save_result:
            output_path = image_path.replace('.jpg', '_detected.jpg').replace('.png', '_detected.png')
            cv2.imwrite(output_path, result_image)
            print(f"üíæ Result saved: {output_path}")
        
        return result_image, holds

def main():
    """Test the custom detector"""
    detector = CustomHoldDetector()
    
    # Test images
    test_images = [
        "frontend/FermataBeta/src/images/2.jpg",  # Your test image
        "frontend/FermataBeta/src/images/images.jpeg",  # Another test image
        # Add more image paths here
    ]
    
    for image_path in test_images:
        if os.path.exists(image_path):
            print(f"\n{'='*50}")
            result_image, holds = detector.process_image(image_path)

            # --- Save holds data as JSON ---
            # Convert tuples to lists for JSON compatibility
            holds_json = []
            for hold in holds:
                hold_copy = hold.copy()
                if isinstance(hold_copy['center_px'], tuple):
                    hold_copy['center_px'] = list(hold_copy['center_px'])
                if isinstance(hold_copy['bbox'], tuple):
                    hold_copy['bbox'] = list(hold_copy['bbox'])
                holds_json.append(hold_copy)
            # Write to file (one file per image)
            json_filename = os.path.splitext(os.path.basename(image_path))[0] + "_holds.json"
            with open(json_filename, "w") as f:
                json.dump(holds_json, f, indent=2)
            print(f"üíæ Holds data saved to {json_filename}")
            # --- End JSON save ---

            if result_image is not None:
                # Display result
                cv2.imshow('Custom Hold Detection', result_image)
                print("Press any key to continue to next image...")
                cv2.waitKey(0)
                cv2.destroyAllWindows()
        else:
            print(f"‚ö†Ô∏è  Image not found: {image_path}")

if __name__ == "__main__":
    main()